package org.example.backend.service.impl.account;

import lombok.RequiredArgsConstructor;
import org.example.backend.config.CustomPasswordEncoder;
import org.example.backend.dto.request.account.AccountDTORequest;
import org.example.backend.dto.response.account.AccountDTOResponse;
import org.example.backend.entity.child.account.Account;
import org.example.backend.entity.child.account.User;
import org.example.backend.entity.child.account.client.Client;
import org.example.backend.entity.child.account.freelancer.Freelancer;
import org.example.backend.exception.NotFoundException;
import org.example.backend.mapper.Account.AccountMapper;
import org.example.backend.repository.AccountRepository;
import org.example.backend.repository.ClientRepository;
import org.example.backend.repository.FreelancerRepository;
import org.example.backend.repository.UserRepository;
import org.example.backend.service.intf.account.AccountService;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
public class AccountServiceImpl implements AccountService {

    private final AccountRepository accountRepository;
    private final AccountMapper accountMapper;

    private final UserRepository userRepository;

    private final FreelancerRepository freelancerRepository;

    private final ClientRepository clientRepository;

    private final PasswordEncoder passwordEncoder;

    @Transactional
    @Override
    public AccountDTOResponse create(AccountDTORequest accountRequestDTO) {
        // Kiểm tra email trùng lặp
        if (accountRepository.existsByEmail(accountRequestDTO.getEmail())) {
            throw new IllegalArgumentException("Account with email " + accountRequestDTO.getEmail() + " already exists");
        }

        // Tạo entity Account từ DTO và mã hóa mật khẩu
        Account account = accountMapper.toEntity(accountRequestDTO);
        account.setPassword(passwordEncoder.encode(accountRequestDTO.getPassword()));

        // Lưu tài khoản
        Account savedAccount = accountRepository.save(account);

        // Tạo entity User từ DTO và liên kết với tài khoản đã lưu
        User user = mapUserFromDTO(accountRequestDTO, savedAccount);
        userRepository.save(user);

        // Gắn user vào account và lưu lại
        savedAccount.setUser(user);
        accountRepository.save(savedAccount);

        // Tạo thêm các entity đặc thù dựa trên vai trò
        saveRoleSpecificEntity(accountRequestDTO.getRole(), user);

        // Trả về DTO Response
        return accountMapper.toResponseDto(savedAccount);
    }

    // Hàm tạo User từ DTO
    private User mapUserFromDTO(AccountDTORequest dto, Account account) {
        User user = new User();
        user.setFirstName(dto.getFirstName());
        user.setLastName(dto.getLastName());
        user.setPhoneNumber(dto.getPhoneNumber());
        user.setAddress(dto.getAddress());
        user.setTitle(dto.getTitle());
        user.setIntroduction(dto.getIntroduction());
        user.setAccount(account);
        return user;
    }

    // Hàm lưu các entity đặc thù theo vai trò
    private void saveRoleSpecificEntity(String role, User user) {
        if ("freelancer".equalsIgnoreCase(role)) {
            Freelancer freelancer = new Freelancer();
            freelancer.setUser(user);
            freelancerRepository.save(freelancer);
        } else if ("client".equalsIgnoreCase(role)) {
            Client client = new Client();
            client.setUser(user);
            clientRepository.save(client);
        }
    }



    @Override
    public Optional<AccountDTOResponse> getById(Long id) {
        return Optional.ofNullable(accountRepository.findById(id)
                .map(accountMapper::toResponseDto)
                .orElseThrow(() -> new NotFoundException("Account with ID " + id + " not found")));
    }

    @Override
    public List<AccountDTOResponse> getAll() {
        List<Account> accounts = accountRepository.findAll();

        if (accounts.isEmpty()) {
            throw new NotFoundException("No accounts found");
        }
        return accountMapper.toResponseDtoList(accounts);
    }

    @Override
    public Boolean deleteById(Long id) {
        return null;
    }
}
